MetaMorphosisBroker
    MessageStoreManager
        MessageStore
            loadSegments()
            Segment: 表示一个具体的文件。
                FileMessageSet：
    ExecutorsManager
    RemotingServer
    MetaConfig
    BrokerZooKeeper
    TransactionalCommandProcessor
        BrokerCommandProcessor
            processPutCommand()  : 如果对应的分区不存在， 在broker上创建一个分区，
                                    同时会调用BrokerZooKeeper.registerTopicInZkInternal()到zk上注册 topic的相关的信息。
            processGetCommand()  :如果对应的分区不存在，直接返回错误



    TransactionProcessor

1. consumer 订阅时，并不能指定获取消息数，只能指定字节数。
即使多个client同时读取同一个Channel，transferFrom指定了offset、size，应该是线程安全的。
FileChannel的线程安全性：操作都是线程安全的，除了改变position、大小的操作多线程环境下会被block。

FileChannel.transferTo 依赖于sendfile ,直接从kernel buffer 拷贝到 socket网卡上去。
http://blog.csdn.net/jiangbo_hit/article/details/6146502

使用zk
1.broker启动
BrokerZooKeeper.registerBrokerInZk()  //注册broker
BrokerZooKeeper.registerTopicInZkInternal()  //注册topic

2. 在MetaConfig中注册了Listener 在 topic发送变化时，注册topic信息。
 MetaMorphosisBroker.addTopicsChangeListener

ProducerZooKeeper.syncedUpdateBrokersInfo


事务 
生产者才需要用到。

组提交

主从复制






broker:
/brokers/ids/[brokerId]  meta://host:port

topic:
/brokers/topics/[topic]/[brokerId]-(s|m)  : [parts]


/brokers/topics-pub/[topic]/[brokerId]-(s|m) : {"numParts":xxx, "broker":"[brokerId]-(s|m)"}
/brokers/topics-sub/[topic]/[brokerId]-(s|m) : {"numParts":xxx, "broker":"[brokerId]-(s|m)"}




slaveId=1

slaveGroup=meta-slave-group

https://github.com/killme2008/Metamorphosis/wiki/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90

Broker Node Registry

/brokers/ids/[0…N] –> host:port (ephemeral node) 
[0…N]表示是broker id，每个broker id 必须唯一。在broker启动时就完成注册。 
含义是每个broker对应的host:port

Broker Topic Registry

/brokers/topics/[topic]/[0…N] –> nPartions (ephemeral node) 
含义是每个broker id 对应主题的分区数

Consumer Id Registry

消费者群组含有多个消费者，不同消费者名称不同。每个消费者含有一个group id属性。

/consumers/[group_id]/ids/[consumer_id] –> {“topic1”: #streams, …, “topicN”: #streams} (ephemeral node)

含义是每个消费者群组下面的消费者所消费的topic列表。

Consumer Offset Tracking

/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id] –> offset_counter_value ((persistent node)

每个消费者群组对某个主题的服务器id-分区id消费的offset_counter_value

Partition Owner registry

/consumers/[group_id]/owners/[topic]/[broker_id-partition_id] –> consumer_node_id (ephemeral node)

含义是某消费者群组的某个consumer_node_id对某个主题的服务器id-分区id消费

Broker node registration

当新borker加入是，它注册在broker节点下，value是hostname和port。它同时也注册它含有的topic列表和topic的分区情况。新主题被创建时会自动注册到zk上。

Consumer registration algorithm

当消费者启动时：

把自己注册到某个消费者群组
在consumer id下，注册监听change事件（新消费者离开或者加入），每次变化会重新计算该群组下的消费者负载。
在broker id下，注册监听change事件（新borker离开或者加入），每次变化会重新计算所有消费者群组的消费者负载。
如果某个消费者使用了topic filter机制，那么它会在broker topic下注册change事件（新主题加入），每次变化会重新计算相关联的topic的消费者的负载。
当自己加入后，重新计算消费者群组的消费者负载。